# EdgeFS

EdgeFS是针对边缘存储设计的文件系统，基于Fuse用户态文件系统实现，主要应用于CDN。  
边缘计算结课作业（所以能跑就行）。

# 思路概要（想到什么写什么，等全部完成了以后再正式整理）

- **主打一个不考虑性能，怎么简单怎么来，主要为了验证可行。**
- 系统模型是经典的CDN模型，有一个数据中心和多个边缘节点组成。
- EdgeFS是一个全内存的文件系统，它不真正存储文件数据，只负责管理文件元数据，真正的文件数据保存在别的文件系统下。EdgeFS会管理数据中心文件在本地边缘节点的缓存，动态地拉取文件、维护文件和删除冷文件，以达成加速用户访问的目的。
- 考虑到CDN的应用场景，EdgeFS只提供读接口，表现为**只读**文件系统。用户无法直接通过EdgeFS修改文件，EdgeFS只能通过回收旧数据，从数据中心拉取新数据以达成更新操作。
- 对于大文件，大部分时候用户不需要请求整个文件，热点数据往往在其中的某一段，EdgeFS会对文件分片管理，称之为chunck。
- 进一步会设置内存缓存，用于缓存热点数据中的热点，把边缘节点的内存充分利用上进一步加速，以block为单位。

# 具体设计（有待改进）

## 系统结构
  - 一个数据中心和多个边缘节点，数据中心和边缘节点之间的通信通过RPC。

  - 目前EdgeFS是全内存文件系统，用户通过EdgeFS访问文件时，它需要进一步在其它文件系统下存储和读取数据。（主要是结课作业时间紧，而且没必要，就偷懒借用别的文件系统来真正读写块设备了。这也导致了每次读写都要多次经过VFS，频繁的用户态/内核态切换注定了很低的性能）
  
  - 除了FUSE本身的守护进程意外，还开辟了三个线程：  
    
    1. PULL_AND_GC() : 负责数据的拉取和回收，不断从FIFO请求队列里取出请求并执行相应操作
    2. SCAN() : 周期性扫描文件状态，识别冷数据相应发起GC请求放入请求队列中
    3. RPC() : RPC服务器，主要用于数据中心向边缘节点发送文件失效通知

## 系统接口
  
  对外只提供FUSE的三个接口：getattr(), readdir(), read()

## 存储结构
  
  EdgeFS会在内存中按照树形结构维护dentry和inode。对于EdgeFS下的每个文件，都会相应在指定的数据根目录下以相同的路径维护一个目录，存放文件的chunck，按照chunck号命名每个chunck文件。每个chunck又会进一步被划分为block，作为缓存在内存中的单位，读文件最终会按照block读取。  

  用户发起读请求后流程：  
  
  1. EdgeFS解析路径，尝试找到对应的dentry。若失败，会发起一个PULL请求从数据中心拉取文件，并立刻返回。
  2. EdgeFS找到对应dentry，并相应找到inode。EdgeFS将read请求的offset和size，根据inode提供的chunck size，转化为将要读取chunck号和每个chunck内的读取范围。
  3. EdgeFS根据inode内的chunck bitmap判断目标chunck是否都在边缘节点上。若有chunck缺失，则读取失败，发起缺失chunck的PULL请求，并立刻返回。
  4. 若chunck齐全，开始对每个chunck文件读取。对每个chunck的读取，会进一步划分为block的读取。对每个subinode检查block bitmap，查看目标block是否已经被缓存在了内存中，若有则直接读取，若无则将启动磁盘IO读取，并将其缓存。
  5. 完成read并返回。

## GC和PULL

  垃圾回收GC和数据拉取PULL有一个线程专门负责。GC请求和PULL请求共享一个请求队列，线程不断从队头取出请求，分别根据请求类型处理。

  - PULL请求  
    1. 请求中包含**请求发起时戳、路径、chunck大小、起始chunck和chunck数量**。
    2. 对请求中所指定的路径，搜寻相应的dentry。如果不存在，则通过RPC发起数据拉取请求。
    3. 如果存在dentry，判断文件状态。①如果为正常状态，则判断请求的chunck是否已经存在，相应修改或取消拉取请求，并发送给数据中心；②如果为冷数据等待GC状态，则重置为正常状态，并执行第一章情况；③如果为失效状态，则直接发起拉取请求。
    4. 数据中心接到请求后，判断请求发起时戳和目标文件最后修改时戳，若请求时戳大于最后修改时戳，则返回指定数据，否则拒绝拉取请求。
    5. 边缘接收到返回数据，做相应处理。
   
  - GC请求  
    1. 请求中包含**请求发起时戳、路径、起始chunck、chunck数量和GC原因**。
    2. 对请求中所指定的路径，搜寻对应的dentry。如果不存在，忽略请求。
    3. 如果起始chunck和chunck数量均为特殊值（表示全部回收）且GC原因为文件失效，判断文件当前是否处于失效状态，如果不是则忽略请求，否则执行请求全部回收。
    4. 判断请求发起时戳和文件最后修改时戳，若请求发起时戳小于文件最后修改时戳，忽略请求。
    5. 判断目标chunck是否存在且处于等待回收状态，如果不处于则不回收该chunck，否则正常回收。

## SCAN

  SCAN线程周期性地扫描所有dentry，通过**缓存建立时间、最后访问时间、访问次数**来综合判断chunck是否还应该缓存在本地，相应发起GC请求。SCAN线程还会负责block的扫描判断，回收内存。

## RPC

  RPC线程负责运行一个RPC服务，主要用于接收来自数据中心的主动消息。目前只有文件失效一个通知。

